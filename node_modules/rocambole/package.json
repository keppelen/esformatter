{
  "name": "rocambole",
  "version": "0.1.0",
  "description": "Recursively walk and transform EcmaScript AST",
  "main": "lib/walker.js",
  "directories": {
    "test": "test"
  },
  "scripts": {
    "test": "node ./node_modules/.bin/jasmine-node test"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/millermedeiros/rocambole.git"
  },
  "bugs": {
    "url": "https://github.com/millermedeiros/rocambole/issues"
  },
  "keywords": [
    "ast",
    "walk",
    "syntax",
    "source",
    "tree",
    "traversal",
    "falafel",
    "burrito",
    "esprima"
  ],
  "author": {
    "name": "Miller Medeiros",
    "email": "http://blog.millermedeiros.com"
  },
  "license": "MIT",
  "dependencies": {
    "esprima": "~1.0.2",
    "amd-utils": "~0.8.1"
  },
  "devDependencies": {
    "jasmine-node": "~1.0.26"
  },
  "readme": "# Rocambole : Recursively walk and transform EcmaScript AST\n\nAdd extra information/helpers to [Esprima / Mozilla SpiderMonkey Parser\nAPI](http://esprima.org/doc/index.html#ast) compatible AST and provides\ndifferent methods for walking the tree recursively.\n\nThe main difference between other tools is that it also keeps information about\ntokens and white spaces and it is meant to be used to transform the tokens and\nnot the string values itself.\n\nThis library is specially useful for non-destructive AST manipulation.\n\n\n## Inspiration\n\nThis module was heavily inspired by\n[node-falafel](https://github.com/substack/node-falafel) and\n[node-burrito](https://github.com/substack/node-burrito) but I needed more\ninformation than what is currently available on falafel (specially about\ntokens, empty lines and white spaces).\n\nThe amount of changes required to introduce the new features and the\ndifferences on the concept behind the tool justified a new project.\n\n\n\n## Extra Tokens\n\nBesides all the regular tokens returned by `esprima` we also add a few more\nthat are important for non-destructive transformations.\n\n * WhiteSpace\n   - Can store multiple white spaces (tabs are considered white space, line\n     breaks not). Important if you want to do non-destructive replacements that\n     are white-space sensitive.\n   - Multiple subsequent white spaces are treated as a single token.\n * LineBreak\n * LineComment\n * BlockComment\n\n\n\n## Extra Properties\n\nEach Node have the following extra properties/methods:\n\n  - parent : Node|undefined\n  - toString() : string\n  - next : Node|undefined\n  - prev : Node|undefined\n  - depth : Number\n  - startToken : Token\n  - endToken : Token\n  - getTokens() : Array<Token>\n\nEach token also have:\n\n - prev : Token|undefined\n - next : Token|undefined\n - before(newToken)\n  - insert a new token before\n - after(newToken)\n  - insert a new token after\n - remove()\n  - remove token from the tree\n\nPS: all manipulation methods update `range` and `loc` of all tokens till the\nend of the list.\n\nThe AST root (Program) also have an extra property `nodes`, which contain all\nNodes that are present inside the `Program.body`. The `nodes` array is *not*\nsorted on any specific way, order of elements is not guaranteed. It is used\ninternally by the `moonwalk`.\n\nYou should threat the tokens as a linked list, so to loop between all tokens\ninside a node you can do like this:\n\n```js\nvar token = node.startToken;\nwhile (token !== node.endToken.next) {\n    doStuffWithToken(token);\n    token = token.next;\n}\n```\n\n\n\n## Notes\n\nThe `moonwalk()` starts at the leaf nodes and go down the tree until it reaches\nthe root node (`Program`). Each node will be traversed only once.\n\n```\n Program [#18]\n |-FunctionDeclaration [#16]\n | |-BlockStatement [#14]\n | | |-IfStatement [#12]\n | | | |-BynaryExpression [#9]\n | | | | |-Identifier [#4]\n | | | | `-Literal [#5]\n | | | `-BlockStatement [#10]\n | | |   `-ExpressionStatement [#6]\n | | |     `-AssignmentExpression [#3]\n | | |       |-Identifier [#1 walk starts here]\n | | |       `-Literal [#2]\n | | `-VariableDeclaration [#13]\n | |   `-VariableDeclarator [#11]\n | |     |-Identifier [#7]\n | |     `-Literal [#8]\n   `-ReturnStatement [#17]\n     `-Identifier [#15]\n```\n\nThis behavior is very different from node-falafel and node-burrito.\n\n\n\n## API\n\n```js\nvar rocambole = require('rocambole');\n\n// it parses a string and instrument the AST with extra properties/methods\nvar instrumentedAst = rocambole.parse(string);\n\n// moonwalk() starts from the deepest nodes and walk the tree backwards\nrocambole.moonwalk(instrumentedAst, function(node){\n    if (node.type == 'ArrayExpression'){\n        console.log( node.toString() );\n    }\n});\n\n// you also have the option to do a recursive walk (similar to node-falafel)\nrocambole.recursive(instrumentedAst, function(node){\n    console.log(node.type);\n});\n\n// call toString() to get a string representation of all tokens\nvar result = instrumentedAst.toString();\n```\n\n\n\n## Popular Alternatives\n\n - [burrito](https://github.com/substack/node-burrito)\n - [falafel](https://github.com/substack/node-falafel)\n\n\n\n\n## TODO\n\n - add a method similar to falafel `node.update(str)` but that actually\n   converts the string into tokens before inserting.\n\n\n\n## License\n\nMIT\n\n\n",
  "_id": "rocambole@0.1.0",
  "_from": "rocambole@~0.1"
}
